
/**
 * Safely resolves a dotted property path on an object.
 *
 * @param {Object} root - Root object (e.g., objItem, globalThis)
 * @param {string} path - Dot-delimited property path
 * @returns {*} Resolved value or undefined
 */
function resolvePath(root, path) {
    return path
    .split(".")
    .reduce((acc, key) => acc && acc[key], root);
}
/**
 * ============================================================
 * Class: BrowserTab
 * ============================================================
 * Utility class responsible for safely opening a new browser
 * tab (or window) and injecting HTML content into it.
 *
 * Designed specifically for bookmarklet usage with:
 * - Popup-blocker handling
 * - Cross-browser compatibility
 * - Simple static API
 */
class BrowserTab {

    /**
     * Opens a new browser tab and writes a full HTML document.
     *
     * @param {string} htmlContent - Fully composed HTML string
     * @param {string} [windowName="_blank"] - Optional window name
     * @returns {void}
     */
    static openWithHTML(htmlContent, windowName = "_blank") {
        const win = window.open("", windowName);

        if (!win) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
        }

        try {
            win.document.open();
            win.document.write(htmlContent);
            win.document.close();
            win.focus();
        } catch (error) {
            console.error("BrowserTab error:", error);
        }
    }
}

/**
 * ============================================================
 * Base Class: ListofObj_Base
 * ============================================================
 * Shared base class for transforming collections of objects
 * using a schema-driven mapping.
 *
 * Responsibilities:
 * - Schema processing
 * - Safe property resolution (no eval)
 * - Row iteration and numbering
 * - Common value formatting
 *
 * Output rendering is delegated to subclasses.
 */
class ListofObj_Base {

    /** @type {string[]} Column headers (includes "No.") */
    header = ["No."];

    /** @type {(string|Function)[]} Field resolvers */
    fields = [];

    /** @type {Object[]} Collection of objects */
    collection = [];

    /** @type {Object[]} schema */
    schema = [];

    /** @type {string} Optional title */
    title = "";

    /**
     * @param {Object} schema
     * Dictionary where:
     * - key   = column header label
     * - value = property path OR function(obj) => value
     *
     * @param {Object[]} collection
     */
    constructor(schema, collection) {
        this.header = this.header.concat(Object.keys(schema));
        this.fields = Object.values(schema);
        this.collection = collection;
        this.schema = schema;
    }

    /**
     * Sets an optional title.
     *
     * @param {string} title
     */
    setTitle(title = "") {
        this.title = title;
    }

    /**
     * Resolves a field value safely.
     *
     * @param {Object} objItem
     * @param {string|Function} resolver
     * @returns {*}
     */
    resolveField(objItem, resolver) {
        if (typeof resolver === "function") {
            return resolver(objItem);
        }
        return resolvePath(objItem, resolver);
    }

    /**
     * Iterates through collection and yields resolved rows.
     *
     * @returns {Array<Array<*>>}
     */
    buildRows() {
        const rows = [];

        for (let i = 0; i < this.collection.length; i++) {
            const objItem = this.collection[i];

            const row = this.fields.map(resolver =>
                    this.resolveField(objItem, resolver));

            rows.push([i + 1, ...row]);
        }

        return rows;
    }

    /**
     * Formats a value into readable text.
     * Shared by all output formats.
     *
     * @param {*} value
     * @returns {string}
     */
    static formatValue(value) {
        if (value == null)
            return "";

        if (typeof value === "object") {
            return Array.from(value)
            .map(v => `${v.name}: ${v.value}`)
            .join("; ");
        }

        return String(value).trim();
    }
}

/**
 * ============================================================
 * Class: ListofObj_to_Table
 * ============================================================
 * Renders collection output as an HTML table.
 */
class ListofObj_to_Table extends ListofObj_Base {

    objCSV = ""; // Defines the string for the raw CSV object

    /**
     * Generates inline CSS styles for the table.
     */
    static tableStyle(headerBackgroundColor = "#FFC107") {
        return `
      <STYLE>
        table, th, td {
          border: 1px solid #9E9E9E;
          border-collapse: collapse;
        }
        th { background: ${headerBackgroundColor}; }
      </STYLE>
    `;
    }

    /**
     * Creates the HTML table output.
     * @param {string} [csvFileName = "download.csv"]
     * @returns {string}
     */
    render(csvFileName = "download.csv") {
        let html = "";

        if (this.title) {
            html += `<H1>${this.title}</H1>`;
        }

        html += ListofObj_to_Table.tableStyle();
        html += "<TABLE><TR>";

        this.header.forEach(h => html += `<TH>${h}</TH>`);
        html += "</TR>";

        const rows = this.buildRows();

        rows.forEach(row => {
            html += "<TR>";
            row.forEach(cell => {
                html += `<TD>${ListofObj_Base.formatValue(cell)}</TD>`;
            });
            html += "</TR>";
        });

        html += "</TABLE><BR>";

        const objDelimTxt = new ListofObj_to_DelimitedText(this.schema, this.collection, {
            columnDelimiter: ",",
            rowDelimiter: "\r\n"
        });
        this.objCSV = objDelimTxt.render();
        html += ListofObj_to_Table.createCSVBloblink(this.objCSV, csvFileName);
        return html;
    }

    /**
     * function createCSVBloblink (objCSV,csvFileName)
     * Formats the A href link for the objCSV so it can be downloadable
     * @param {string} objCSV - string of raw CSV where line breaks delimits rows of comma-separated values
     * @param {string} csvFileName - string of CSV filename. Default is "download.csv"
     * @returns {string}
     */
    static createCSVBloblink(objCSV, csvFileName = "download.csv") {
        let linkText = "Download as CSV";
        let objCSVBlob = new Blob([objCSV], {
            type: "text/csv"
        });
        let csvURL = window.URL.createObjectURL(objCSVBlob);
        let HTMLlink =
            '<A href="' +
            csvURL +
            '" download="' +
            csvFileName +
            '">' +
            linkText +
            "</A>";
        return HTMLlink;
    }

}

/**
 * ============================================================
 * Class: ListofObj_to_DelimitedText
 * ============================================================
 * Renders collection output as delimited plain text.
 */
class ListofObj_to_DelimitedText extends ListofObj_Base {

    /**
     * @param {Object} schema
     * @param {Object[]} collection
     * @param {Object} [options]
     */
    constructor(schema, collection, options = {}) {
        super(schema, collection);

        this.columnDelimiter = options.columnDelimiter ?? ",";
        this.rowDelimiter = options.rowDelimiter ?? "<BR>";
    }

    /**
     * Creates delimited text output.
     *
     * @returns {string}
     */
    render() {
        let output = "";

        if (this.title) {
            output += `<STRONG>${this.title}</STRONG>` + this.rowDelimiter;
        }

        output +=
        this.header.join(this.columnDelimiter) +
        this.rowDelimiter;

        const rows = this.buildRows();

        rows.forEach(row => {
            output +=
            row
            .map(v => ListofObj_Base.formatValue(ListofObj_to_DelimitedText.escapeForCSV(ListofObj_to_DelimitedText.formatCSVcellvalues(v))))
            .join(this.columnDelimiter) +
            this.rowDelimiter;
        });

        return output;
    }
	
	 /**
     * formats the string so that if it has double-quotes, it can be escaped properly for CSV formatting purposes
     * @param {string} inputString - string to be checked and formatted for quotes
     * @returns {string}
     */
    static escapeForCSV(inputString) {
        // Check if the string contains special characters
        if (/[",\n]/.test(inputString)) {
            // Escape double quotes with double quotes and wrap the string in double quotes
            return '"' + inputString.replace(/"/g, '""') + '"';
        }
        return inputString;
    }

    /**
     * Format CSVCellvalues so it can be displayed properly within CSV cells
     * @param {string} strCellinput - object value to be displayed in the CSV cell
     * @returns {string}
     */
    static formatCSVcellvalues(strCellinput) {
        function CSVlistAttributes(arr) {
            let strOutput = "";
            for (let i = 0; i < arr.length; i++) {
                strOutput += arr[i].name + ": " + arr[i].value + ";\n\r";
            }
            return strOutput;
        }

        let strOutput;
        if (typeof strCellinput === "object") {
            strOutput = CSVlistAttributes(strCellinput);
        } else {
            strOutput = String(strCellinput).trim();
        }
        return strOutput;
    }

}
const schema = {
    "Link Text": "innerText",
    "URL": "href",
    "Upper Text": el => el.innerText.toUpperCase()
};

const links = document.querySelectorAll("a");

/* HTML Table */
const table = new ListofObj_to_Table(schema, links);
table.setTitle("Links Table");
const tableHTML = table.render();

/* Delimited Text */
const text = new ListofObj_to_DelimitedText(
        schema,
        links, {
        columnDelimiter: " | "
    });
text.setTitle("Links Text");
const textOutput = text.render();
let html = "";
html += tableHTML;
html += "<BR><BR><BR>";
html += textOutput;
BrowserTab.openWithHTML(html);
